---
export interface Props {
  debug?: boolean;
  endpoint?: string; // Optional endpoint to send metrics to
}

const {
  debug = false,
  endpoint
} = Astro.props;

const isDev = import.meta.env.DEV;
const shouldTrack = !isDev || debug;
---

{shouldTrack && (
  <script is:inline define:vars={{ debug, endpoint }}>
    // Web Vitals tracking - Inspired by AuditMySite Studio
    // üîç Learn more: https://github.com/casoon/auditmysite_studio
    function measureWebVitals() {
      // Core Web Vitals object to store metrics
      const vitals = {};
      let debugContainer;

      // Create debug display container if debug mode is enabled
      if (debug) {
        debugContainer = document.createElement('div');
        debugContainer.id = 'web-vitals-debug';
        debugContainer.innerHTML = `
          <div style="
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
            z-index: 10000;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
          ">
            <div style="font-weight: bold; margin-bottom: 8px; color: #60A5FA;">üìä Web Vitals Debug</div>
            <div style="font-size: 11px; color: #9CA3AF; margin-bottom: 8px;">
              <a href="https://github.com/casoon/auditmysite_studio" target="_blank" style="color: #60A5FA;">‚Üí More analysis with AuditMySite</a>
            </div>
            <div id="vitals-display">Measuring...</div>
          </div>
        `;
        document.body.appendChild(debugContainer);
      }

      function updateDebugDisplay() {
        if (!debug || !debugContainer) return;

        const display = debugContainer.querySelector('#vitals-display');
        const entries = Object.entries(vitals).map(([key, value]) => {
          const formatted = typeof value === 'number' ?
            (key === 'CLS' ? value.toFixed(3) : `${value}ms`) : value;

          let status = '‚è≥';
          if (key === 'LCP' && typeof value === 'number') {
            status = value < 2500 ? '‚úÖ' : value < 4000 ? '‚ö†Ô∏è' : '‚ùå';
          } else if (key === 'FID' && typeof value === 'number') {
            status = value < 100 ? '‚úÖ' : value < 300 ? '‚ö†Ô∏è' : '‚ùå';
          } else if (key === 'INP' && typeof value === 'number') {
            status = value < 200 ? '‚úÖ' : value < 500 ? '‚ö†Ô∏è' : '‚ùå';
          } else if (key === 'CLS' && typeof value === 'number') {
            status = value < 0.1 ? '‚úÖ' : value < 0.25 ? '‚ö†Ô∏è' : '‚ùå';
          } else if (key === 'FCP' && typeof value === 'number') {
            status = value < 1800 ? '‚úÖ' : value < 3000 ? '‚ö†Ô∏è' : '‚ùå';
          } else if (key === 'TTFB' && typeof value === 'number') {
            status = value < 800 ? '‚úÖ' : value < 1800 ? '‚ö†Ô∏è' : '‚ùå';
          } else if (key === 'TBT' && typeof value === 'number') {
            status = value < 200 ? '‚úÖ' : value < 600 ? '‚ö†Ô∏è' : '‚ùå';
          } else if (['DNS', 'TCP', 'DOM', 'LOAD'].includes(key) && typeof value === 'number') {
            status = value < 100 ? '‚úÖ' : value < 300 ? '‚ö†Ô∏è' : '‚ùå';
          }

          return `<div style="margin: 2px 0;">${status} <strong>${key}:</strong> ${formatted}</div>`;
        }).join('');

        display.innerHTML = entries || 'Measuring...';
      }

      // 1. Largest Contentful Paint (LCP)
      function measureLCP() {
        const observer = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const lastEntry = entries[entries.length - 1];
          vitals.LCP = Math.round(lastEntry.startTime);

          sendMetric('LCP', vitals.LCP);
          updateDebugDisplay();
          observer.disconnect();
        });

        observer.observe({ type: 'largest-contentful-paint', buffered: true });
      }

      // 2. First Input Delay (FID) - only measures on first interaction
      function measureFID() {
        const observer = new PerformanceObserver((list) => {
          const firstEntry = list.getEntries()[0];
          vitals.FID = Math.round(firstEntry.processingStart - firstEntry.startTime);

          sendMetric('FID', vitals.FID);
          updateDebugDisplay();
          observer.disconnect();
        });

        observer.observe({ type: 'first-input', buffered: true });
      }

      // 3. Cumulative Layout Shift (CLS)
      function measureCLS() {
        let clsValue = 0;

        const observer = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (!entry.hadRecentInput) {
              clsValue += entry.value;
            }
          }

          vitals.CLS = Math.round(clsValue * 1000) / 1000;
          sendMetric('CLS', vitals.CLS);
          updateDebugDisplay();
        });

        observer.observe({ type: 'layout-shift', buffered: true });

        // Send final CLS when page is hidden (user navigates away)
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden') {
            observer.disconnect();
          }
        });
      }

      // 4. First Contentful Paint (FCP)
      function measureFCP() {
        const observer = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const fcpEntry = entries.find(entry => entry.name === 'first-contentful-paint');

          if (fcpEntry) {
            vitals.FCP = Math.round(fcpEntry.startTime);
            sendMetric('FCP', vitals.FCP);
            updateDebugDisplay();
            observer.disconnect();
          }
        });

        observer.observe({ type: 'paint', buffered: true });
      }

      // 5. Time to First Byte (TTFB)
      function measureTTFB() {
        const navigationEntry = performance.getEntriesByType('navigation')[0];
        if (navigationEntry) {
          vitals.TTFB = Math.round(navigationEntry.responseStart - navigationEntry.requestStart);
          sendMetric('TTFB', vitals.TTFB);
          updateDebugDisplay();
        }
      }

      // 6. Interaction to Next Paint (INP) - New metric replacing FID
      function measureINP() {
        let maxDelay = 0;
        const observer = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          entries.forEach((entry) => {
            const delay = entry.processingStart - entry.startTime;
            if (delay > maxDelay) {
              maxDelay = delay;
              vitals.INP = Math.round(maxDelay);
              sendMetric('INP', vitals.INP);
              updateDebugDisplay();
            }
          });
        });

        observer.observe({ type: 'event', buffered: true });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
          observer.disconnect();
        });
      }

      // 7. Total Blocking Time (TBT) - Estimate
      function measureTBT() {
        let totalBlockingTime = 0;
        const observer = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          entries.forEach((entry) => {
            if (entry.duration > 50) {
              totalBlockingTime += entry.duration - 50;
              vitals.TBT = Math.round(totalBlockingTime);
              sendMetric('TBT', vitals.TBT);
              updateDebugDisplay();
            }
          });
        });

        observer.observe({ type: 'longtask', buffered: true });
      }

      // 8. Navigation Timing Metrics
      function measureNavigationTiming() {
        const navigationEntry = performance.getEntriesByType('navigation')[0];
        if (navigationEntry) {
          vitals.DNS = Math.round(navigationEntry.domainLookupEnd - navigationEntry.domainLookupStart);
          vitals.TCP = Math.round(navigationEntry.connectEnd - navigationEntry.connectStart);
          vitals.DOM = Math.round(navigationEntry.domContentLoadedEventEnd - navigationEntry.responseEnd);
          vitals.LOAD = Math.round(navigationEntry.loadEventEnd - navigationEntry.loadEventStart);

          sendMetric('DNS', vitals.DNS);
          sendMetric('TCP', vitals.TCP);
          sendMetric('DOM', vitals.DOM);
          sendMetric('LOAD', vitals.LOAD);
          updateDebugDisplay();
        }
      }

      // Send metric to endpoint or console
      function sendMetric(name, value) {
        const metric = {
          name,
          value,
          url: window.location.href,
          timestamp: Date.now()
        };

        if (endpoint) {
          // Send to your analytics endpoint
          fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(metric)
          }).catch(err => console.warn('Failed to send metric:', err));
        }

        // Always log in debug mode
        if (debug) {
          console.table([metric]);
        }
      }

      // Initialize measurements
      measureTTFB();
      measureNavigationTiming();
      measureFCP();
      measureLCP();
      measureFID();
      measureINP();
      measureCLS();
      measureTBT();

      if (debug) {
        // Initial display update
        setTimeout(() => updateDebugDisplay(), 100);
      }
    }

    // Start measuring when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', measureWebVitals);
    } else {
      measureWebVitals();
    }
  </script>
)}
